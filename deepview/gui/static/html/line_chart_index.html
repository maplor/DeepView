<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Line Charts</title>
    <!-- <script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script> -->
    <script src="../js/echarts.min.js"></script>
    <script src="qrc:///qtwebchannel/qwebchannel.js"></script>
    <style>
        /* .chart-box {
            width: 600px;
            height: 400px;
            margin: 10px;
            border: 1px solid #ccc;
        } */
        html,
        body {
            height: 100%;
            margin: 0;
            background-color: #19232d;
            overflow-x: hidden;
        }

        body.dark-mode {
            background-color: #19232d;
            color: white;
        }

        body.light-mode {
            background-color: #FAFAFA;
            color: black;
        }

        #container {
            width: 100%;
            /* height: 100%; */
            height: 600px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            flex-direction: column;
        }

        /* 不设置最小高度的话去掉border会导致最后一个图表丢失 */
        .chart-box {
            width: 100%;
            min-height: 50px;
            /* 设置最小高度 */
            /* margin: 2px 0;  */
            /* background-color: lightblue; */
            /* border: 1px solid #ccc; */
        }

        .chart-box:first-child {
            /* height: 150px; */
            height: 80px;
            min-height: 50px;
            /* 设置最小高度 */
            /* 固定高度 */
            flex: 0 0 auto;
            /* 固定大小，不参与均分 */
        }

        .chart-box:not(:first-child) {
            flex: 1;
            /* 均分剩余高度 */
        }

        .chart-container {
            width: 100%;
            height: 100%;
        }

        /* body {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
        } */
    </style>
</head>

<body class="light-mode">
    <div id="container"></div>

    <script type="text/javascript">
        // selectedOption = {};

        findDatastatus = false;

        markData = [];
        otherMarkData = [];
        selectedDataList = null;
        chartsTheme = 'light';
        oldFrame = null;
        delectState = false;
        currentIndex = -1;
        lineOption = null;
        dataFrame = null;
        hasGraphic = false;
        let isBoxDrawn = false;
        let currentBox = null; // 用于存储当前绘制的框
        let filteredData = null;

        // 预定义颜色数组
        // const colorPalette = ['#91cc75', '#5470c6', '#fac858', '#ee6666',
        //     '#73c0de', '#3ba272', '#fc8452', '#9a60b4',
        //     '#ea7ccc', '#fff018', '#6800ff', '#4bb0ff',
        //     '#1bff00', '#09ffdb'];
        const colorPalette = [];
        let usedColors = new Set(); // 用于跟踪已使用的颜色  

        labelColors = {};
        onbrush = false;
        // 全局变量存储框选的范围
        let brushAreas = [];
        charts = [];
        // 同步操作标志
        isSyncing = false;
        // 第一个图表的特殊配置
        selectedOption = {
            grid: {
                top: 10,
                bottom: 20
            },
            xAxis: {
                type: 'category',
                data: [] // 保持与原始图表一致的X轴数据
            },
            yAxis: {
                type: 'value',
                min: 1 // 设置y轴最小值为1
            },
            graphic: [],
            series: [{
                type: 'line',
                markArea: {
                    data: [],
                    label: {
                        show: true, // 显示标签
                        position: 'inside', // 标签位置为区域内部
                        color: '#000', // 标签颜色
                        fontSize: 14, // 标签字体大小
                        formatter: function (params) {
                            return params.name; // 使用区域的名称作为标签内容
                        }
                    }
                },
                data: [], // 空数据
                showSymbol: false, // 不显示数据点
                lineStyle: {
                    opacity: 0 // 使线条透明
                }
            }],
            dataZoom: [
                {
                    type: 'inside',
                    xAxisIndex: [0],
                    start: 0,
                    end: 100
                }
            ]
        };

        // 定义dark主题
        var darkTheme = {
            backgroundColor: '#19232d',
            title: {
                textStyle: {
                    color: '#eeeeee'
                },
                subtextStyle: {
                    color: '#aaaaaa'
                }
            },
            categoryAxis: {
                axisLine: {
                    show: true,
                    lineStyle: {
                        color: "#eeeeee"
                    }
                },
                axisTick: {
                    show: true,
                    lineStyle: {
                        color: "#eeeeee"
                    }
                },
                axisLabel: {
                    show: true,
                    color: "#eeeeee"
                },
                splitLine: {
                    show: true,
                    lineStyle: {
                        color: ["#aaaaaa"]
                    }
                },
                splitArea: {
                    show: false,
                    areaStyle: {
                        color: ["#eeeeee"]
                    }
                }
            },

            valueAxis: {
                axisLine: {
                    show: true,
                    lineStyle: {
                        color: "#eeeeee"
                    }
                },
                axisTick: {
                    show: true,
                    lineStyle: {
                        color: "#eeeeee"
                    }
                },
                axisLabel: {
                    show: true,
                    color: "#eeeeee"
                },
                splitLine: {
                    show: true,
                    lineStyle: {
                        color: ["#aaaaaa"]
                    }
                },
                splitArea: {
                    show: false,
                    areaStyle: {
                        color: ["#eeeeee"]
                    }
                }
            },
            logAxis: {
                axisLine: {
                    show: true,
                    lineStyle: {
                        color: "#eeeeee"
                    }
                },
                axisTick: {
                    show: true,
                    lineStyle: {
                        color: "#eeeeee"
                    }
                },
                axisLabel: {
                    show: true,
                    color: "#eeeeee"
                },
                splitLine: {
                    show: true,
                    lineStyle: {
                        color: ["#aaaaaa"]
                    }
                },
                splitArea: {
                    show: false,
                    areaStyle: {
                        color: ["#eeeeee"]
                    }
                }
            },
            toolbox: {
                iconStyle: {
                    borderColor: "#999999"
                },
                emphasis: {
                    iconStyle: {
                        borderColor: "#666666"
                    }
                }
            },
            legend: {
                textStyle: {
                    color: "#eeeeee"
                }
            },
            tooltip: {
                axisPointer: {
                    lineStyle: {
                        color: "#eeeeee",
                        width: "1"
                    },
                    crossStyle: {
                        color: "#eeeeee",
                        width: "1"
                    }
                }
            }
        };

        var lightTheme = {
            backgroundColor: '#FAFAFA',
            title: {
                textStyle: {
                    color: "#333333"
                },
                subtextStyle: {
                    color: "#aaaaaa"
                }
            },
            categoryAxis: {
                axisLine: {
                    show: true,
                    lineStyle: {
                        color: "#333"
                    }
                },
                axisTick: {
                    show: true,
                    lineStyle: {
                        color: "#333"
                    }
                },
                axisLabel: {
                    show: true,
                    color: "#333"
                },
                splitLine: {
                    show: false,
                    lineStyle: {
                        color: [
                            "#ccc"
                        ]
                    }
                },
                splitArea: {
                    show: false,
                    areaStyle: {
                        color: [
                            "rgba(250,250,250,0.3)",
                            "rgba(200,200,200,0.3)"
                        ]
                    }
                }
            },
            valueAxis: {
                axisLine: {
                    show: true,
                    lineStyle: {
                        color: "#333"
                    }
                },
                axisTick: {
                    show: true,
                    lineStyle: {
                        color: "#333"
                    }
                },
                axisLabel: {
                    show: true,
                    color: "#333"
                },
                splitLine: {
                    show: true,
                    lineStyle: {
                        color: [
                            "#ccc"
                        ]
                    }
                },
                splitArea: {
                    show: false,
                    areaStyle: {
                        color: [
                            "rgba(250,250,250,0.3)",
                            "rgba(200,200,200,0.3)"
                        ]
                    }
                }
            },
            logAxis: {
                axisLine: {
                    show: true,
                    lineStyle: {
                        color: "#333"
                    }
                },
                axisTick: {
                    show: true,
                    lineStyle: {
                        color: "#333"
                    }
                },
                axisLabel: {
                    show: true,
                    color: "#333"
                },
                splitLine: {
                    show: true,
                    lineStyle: {
                        color: [
                            "#ccc"
                        ]
                    }
                },
                splitArea: {
                    show: false,
                    areaStyle: {
                        color: [
                            "rgba(250,250,250,0.3)",
                            "rgba(200,200,200,0.3)"
                        ]
                    }
                }
            },
            toolbox: {
                iconStyle: {
                    borderColor: "#06467c"
                },
                emphasis: {
                    iconStyle: {
                        borderColor: "#4187c2"
                    }
                }
            },
            legend: {
                textStyle: {
                    color: "#333333"
                }
            },
            tooltip: {
                axisPointer: {
                    lineStyle: {
                        color: "#cccccc",
                        width: 1
                    },
                    crossStyle: {
                        color: "#cccccc",
                        width: 1
                    }
                }
            },

        };

        let test_data = '{"metadata": [{"name": "gps", "xAxisName": "timestamp", "yAxisName": "Y Axis 1", "series": ["GPS_velocity", "GPS_bearing"]}, {"name": "acceleration", "xAxisName": "timestamp", "yAxisName": "Y Axis 1", "series": ["acc_x", "acc_y", "acc_z"]}], "data": [{"timestamp": "2018-09-10T20:13:05.000Z", "unixtime": 1536610385.0, "index": 0, "latitude": 38.67688, "longitude": 139.408737, "GPS_velocity": 5.807178554133101, "GPS_bearing": 0.5172438512223761, "acc_x": -0.107422, "acc_y": -0.061035, "acc_z": 1.956055}, {"timestamp": "2018-09-10T20:13:05.038Z", "unixtime": 1536610385.0384, "index": 1, "latitude": 38.67688, "longitude": 139.408737, "GPS_velocity": 5.807178554133101, "GPS_bearing": 0.5172438512223761, "acc_x": 0.32007848000000005, "acc_y": -0.18197292, "acc_z": 1.7338668400000001}, {"timestamp": "2018-09-10T20:13:05.076Z", "unixtime": 1536610385.0767999, "index": 2, "latitude": 38.67688, "longitude": 139.408737, "GPS_velocity": 5.807178554133101, "GPS_bearing": 0.5172438512223761, "acc_x": 0.012207319999999966, "acc_y": -0.43542948000000004, "acc_z": 0.19456987999999975}, {"timestamp": "2018-09-10T20:13:05.115Z", "unixtime": 1536610385.1151998, "index": 3, "latitude": 38.67688, "longitude": 139.408737, "GPS_velocity": 5.807178554133101, "GPS_bearing": 0.5172438512223761, "acc_x": 0.035448839999999995, "acc_y": 0.10886707999999995, "acc_z": 1.40343764}, {"timestamp": "2018-09-10T20:13:05.153Z", "unixtime": 1536610385.1536, "index": 4, "latitude": 38.67688, "longitude": 139.408737, "GPS_velocity": 5.807178554133101, "GPS_bearing": 0.5172438512223761, "acc_x": 0.15240240000000002, "acc_y": -0.3635744800000002, "acc_z": 1.48101608}], "labelColors": {"stationary": "#91cc75", "preening": "#5470c6", "bathing": "#fac858", "flight_take_off": "#ee6666", "flight_cruising": "#73c0de", "foraging_dive": "#3ba272", "surface_seizing": "#fc8452", "unknown": "#9a60b4"}}';
        // let org_data = [
        //     { index: 0, timestamp: '2024-07-20T12:00:00Z', _timestamp: 1626787200, acc_x: 0.1, acc_y: 0.2, acc_z: 0.3, gyro_x: 13, gyro_y: 14, gyro_z: 15 },
        //     { index: 1, timestamp: '2024-07-20T12:01:00Z', _timestamp: 1626787260, acc_x: 0.2, acc_y: 0.3, acc_z: 0.4, gyro_x: 13, gyro_y: 14, gyro_z: 15 },
        //     { index: 2, timestamp: '2024-07-20T12:02:00Z', _timestamp: 1626787320, acc_x: 0.3, acc_y: 0.4, acc_z: 0.5, gyro_x: 13, gyro_y: 14, gyro_z: 15 },
        // ];

        // 新的pkl文件里datetime对应毫秒级别时间,转换一下就得到isotime。unixtime对应_timestamp
        let org_data = [];
        let div_chart_name = {};
        let chartsData = [
            {
                name: 'acceleration',
                xAxisName: 'timestamp',
                yAxisName: 'Y Axis 1',
                series: ['acc_x', 'acc_y', 'acc_z']
            },
            {
                name: 'gyroscope',
                xAxisName: 'timestamp',
                yAxisName: 'Y Axis 2',
                series: ['gyro_x', 'gyro_y', 'gyro_z']
            }
        ];

        // firstChartsData是占位图表，固定不变,里面的series是会被作为x轴
        var firstChartsData =
        {
            name: 'seclection',
            xAxisName: 'timestamp',
            yAxisName: 'Y Axis 1',
            series: ['timestamp']
        }

        // const chartsData = [
        //     {
        //         name: 'acceleration',
        //         xAxisName: 'timestamp',
        //         yAxisName: 'Y Axis 1',
        //         series: ['acc_x', 'acc_y', 'acc_z']
        //     },
        //     {
        //         name: 'gyroscope',
        //         xAxisName: 'timestamp',
        //         yAxisName: 'Y Axis 2',
        //         series: ['gyro_x', 'gyro_y', 'gyro_z']
        //     }
        // ];
        function convertData(org_data, firstChartsData, chartsData) {
            const result = {};

            // Initialize xAxis with values
            // result.firstChartsData.xAxisName = data.map(entry => entry[firstChartsData.xAxisName]);

            // // Initialize series arrays
            // firstChartsData.series.forEach(seriesName => {
            //     result[seriesName] = data.map(entry => entry[seriesName]);
            // });
            // Initialize series arrays
            firstChartsData.series.forEach(seriesName => {
                result[seriesName] = org_data.map(entry => {
                    const value = entry[seriesName];
                    return new Date(value).toISOString();
                });
            });

            chartsData.forEach(chart => {
                chart.series.forEach(seriesName => {
                    result[seriesName] = org_data.map(entry => entry[seriesName]);
                });
            });

            return result;
        }


        // const convertedData = convertData(data, firstChartsData, chartsData);
        // console.log(convertedData);

        function initialize() {
            dataFrame = convertData(org_data, firstChartsData, chartsData);


            // 销毁每个 echarts 实例
            if (charts && charts.length > 0) {
                charts.forEach(chart => {
                    chart.dispose();
                });
            }
            charts = [];
            // hasGraphic = false;
            // chartsData.unshift(firstChartsData);

            if (!chartsData.includes(firstChartsData)) {
                chartsData.unshift(firstChartsData);
            }

            // 获取容器元素
            var container = document.getElementById('container');

            // 清空容器中的内容
            container.innerHTML = '';


            // 动态创建多个盒子
            chartsData.forEach((chartData, index) => {
                if (chartData.series && chartData.series.length > 0) {
                    var box = document.createElement('div');
                    box.className = 'chart-box';
                    box.id = 'chart-box-' + (index + 1);
                    container.appendChild(box);
                }
            });

            // 将图表 div 添加到对应的 className 为 chart_box 的容器中
            chartsData.forEach((chartData, index) => {
                if (chartData.series && chartData.series.length > 0) {
                    var box = document.getElementById('chart-box-' + (index + 1));
                    var div = document.createElement('div');
                    div.className = 'chart-container';
                    div.id = 'chart' + (index + 1);
                    boxid = 'chart-box-' + (index + 1)
                    box.appendChild(div);
                    div_chart_name[boxid] = chartData.name;

                    // 获取 box 的宽高
                    var width = box.clientWidth;
                    var height = box.clientHeight;

                    // 配置图表
                    var chart = echarts.init(div, null, {
                        locale: 'EN'
                    });
                    charts.push(chart);

                    if (chartsTheme === 'light') {
                        chart.setOption(lightTheme);
                    } else {
                        chart.setOption(darkTheme);
                    }

                    var series = [];
                    chartData.series.forEach(seriesName => {
                        if (dataFrame[seriesName]) {
                            series.push({
                                name: seriesName,
                                type: 'line',
                                data: dataFrame[seriesName],
                                sampling: 'lttb',
                                emphasis: {
                                    itemStyle: {
                                        color: 'red',
                                        borderColor: 'red',
                                        borderWidth: 4,

                                    },
                                    Symbol: 'circle',
                                    symbolSize: 20
                                }
                            });
                        }
                    });

                    var option = {
                        grid: {
                            top: 10,
                            bottom: 20
                        },
                        title: {
                            // text: 'Line Chart ' + (index + 1)
                            text: chartData.name
                        },
                        // tooltip: {
                        //     trigger: 'axis',
                        // },
                        // axisPointer: {
                        //     link: { xAxisIndex: 'all' },
                        //     label: {
                        //         backgroundColor: '#777'
                        //     }
                        // },
                        brush: {
                            brushType: ['lineX', 'clear'],
                            toolBox: ['lineX', 'clear'],
                            xAxisIndex: 'all',
                        },
                        toolbox: {
                            trigger: 'axis',
                            feature: {
                                brush: {
                                    type: ['lineX', 'clear']
                                }
                            }
                        },
                        legend: {
                            data: chartData.series,
                            orient: 'vertical',
                            right: '5%',
                            top: '10%',
                            animation: false
                        },
                        xAxis: {
                            name: chartData.xAxisName,
                            type: 'category',
                            data: dataFrame[chartData.xAxisName],
                            animation: false,
                            animationThreshold: 1000,
                        },
                        yAxis: {
                            name: chartData.yAxisName,
                            type: 'value',
                            animation: false
                        },
                        series: series,
                        graphic: [],
                        dataZoom: [
                            {
                                type: 'inside',
                                xAxisIndex: [0],
                                start: 0,
                                end: 100
                            }
                        ]
                    };

                    // // 如果是加速度图表，添加 dataZoom 配置
                    // if (chartData.name === 'acceleration') {
                    //     // option.dataZoom.push({
                    //     //     type: 'inside',
                    //     //     yAxisIndex: [0],
                    //     //     start: 0,
                    //     //     end: 100
                    //     // });
                    //     option.dataZoom.push({
                    //             type: 'slider',
                    //             show: true,
                    //             yAxisIndex: [0],
                    //             start: 0,
                    //             end: 100
                    //         });
                    // }

                    // 如果是第一个图表，添加特殊的配置
                    if (index === 0) {
                        selectedOption.xAxis.data = dataFrame[chartData.xAxisName]
                        chart.setOption(selectedOption);
                        return;
                    }

                    // 如果是最后一个图表，添加 dataZoom 配置
                    if (index === chartsData.length - 1) {
                        
                        option.grid = {
                            top: 10
                        };
                        option.dataZoom = [
                            {
                                type: 'slider',
                                show: true,
                                xAxisIndex: [0],
                                start: 0,
                                end: 100
                            },
                            {
                                type: 'inside',
                                xAxisIndex: [0],
                                start: 0,
                                end: 100
                            }
                        ];
                        // if (chartData.name === 'acceleration') {
                        //     option.dataZoom.push({
                        //         type: 'slider',
                        //         show: true,
                        //         yAxisIndex: [0],
                        //         start: 0,
                        //         end: 100
                        //     });
                        // }
                    }
                    chart.setOption(option);

                    chart.on('click', function (params) {
                        var index = params.dataIndex;
                        console.log('click', index);
                        HighlightDotByIndex(index);
                    });


                    // chart.getZr().on('click', function (event) {
                    //     // 没有 target 意味着鼠标/指针不在任何一个图形元素上，它是从“空白处”触发的。
                    //     if (!event.target) {
                    //         // 点击在了空白处，取消高亮。
                    //         chart.dispatchAction({
                    //             type: 'downplay',
                    //             seriesIndex: [0, 1, 2],
                    //             // dataIndex: selectedIndex
                    //         });
                    //     }
                    // });

                    // Add global click event listener
                    chart.getZr().on('click', function (event) {
                        var pointInGrid = chart.convertFromPixel({ seriesIndex: 0 }, [event.offsetX, event.offsetY]);
                        var xAxisValueIndex = Math.round(pointInGrid[0]);
                        if (xAxisValueIndex >= 0 && xAxisValueIndex < option.xAxis.data.length) {
                            HighlightDotByIndex(xAxisValueIndex);
                            var xAxisValue = option.xAxis.data[xAxisValueIndex];
                            console.log('Clicked nearest x-axis point:', xAxisValue);
                        }
                    });

                    // 防抖函数
                    function debounce(func, delay) {
                        let timeout;
                        return function (...args) {
                            clearTimeout(timeout);
                            timeout = setTimeout(() => func.apply(this, args), delay);
                        };
                    }

                    // 监听缩放事件以同步所有图表
                    chart.on('dataZoom', function (params) {
                        console.log("datazoom")
                        if (!isSyncing) {
                            isSyncing = true;
                            charts.forEach(function (otherChart) {
                                if (otherChart !== chart) {
                                    if (params.batch) {
                                        otherChart.dispatchAction({
                                            type: 'dataZoom',
                                            start: params.batch[0].start,
                                            end: params.batch[0].end
                                        });
                                    } else {
                                        otherChart.dispatchAction({
                                            type: 'dataZoom',
                                            start: params.start,
                                            end: params.end
                                        });
                                    }
                                }
                            });
                            // updatePointPosition();
                            isSyncing = false;
                        }

                    });

                    // 防抖的 setOption 调用
                    const debounceSetOption = debounce(function () {
                        charts.forEach(chart => {
                            chart.setOption({
                                graphic: []
                            });
                        });
                    }, 300); // 300 毫秒的延迟，可以根据需要调整

                }
            });
            brushEnd(charts);
        }



        function brushEnd(charts) {
            charts.forEach((chart, index) => {
                chart.on('brushEnd', function (params) {
                    // console.log('BrushEnd Params:', params);

                    if (!params.areas) {
                        console.error('No areas data found in brushEnd params');
                        return;
                    }
                    // selectedData包含了选择的点的所有信息，包括id
                    var selectedData = getSelectedData(org_data, params.areas);
                    // console.log('Selected Data:', selectedData);
                    const currentStartSelectedData = selectedData[0];
                    const currentEndSelectedData = selectedData[selectedData.length - 1];
                    setStartTimeEndtime(currentStartSelectedData.timestamp, currentEndSelectedData.timestamp);
                    setStartAndEndData(currentStartSelectedData.index, currentStartSelectedData.longitude, currentStartSelectedData.latitude, currentEndSelectedData.index, currentEndSelectedData.longitude, currentEndSelectedData.latitude);
                    // 取消其他图表的框选
                    charts.forEach((otherChart, otherIndex) => {
                        if (index !== otherIndex) {
                            otherChart.dispatchAction({
                                type: 'brush',
                                areas: []
                            });
                        }
                    });
                    // 存储框选的范围到全局变量
                    if (params.areas.length > 0) {
                        brushAreas = selectedData
                    }
                    // 测试使用
                    // addLabel('Selected Area');
                });

                document.addEventListener('contextmenu', function (event) {
                    event.preventDefault();
                    charts.forEach((otherChart, otherIndex) => {
                        if (index !== otherIndex) {
                            otherChart.dispatchAction({
                                type: 'brush',
                                areas: []
                            });
                        }
                    });
                    if (onbrush) {
                        chart.dispatchAction({
                            type: 'takeGlobalCursor',
                            key: 'brush',
                            brushOption: {
                                // brushType: 'clear',
                                brushType: false
                            },
                            areas: []
                        });
                        onbrush = false;
                    } else {
                        chart.dispatchAction({
                            type: 'takeGlobalCursor',
                            key: 'brush',
                            brushOption: {
                                brushType: 'lineX',
                                brushMode: 'single',
                            }
                        });
                        onbrush = true;
                    }
                });
            });

            charts[0].on('click', function (params) {
                // console.log('click', params);
                if (params.componentType === 'markArea') {
                    if (delectState) {
                        var markAreaId = params.data.id;
                        if (markAreaId) {

                            backend.confirmDelete().then(userConfirmed => {
                                if (userConfirmed) {
                                    // 同步删除 markData 中的对应数据
                                    markData = markData.filter(function (area) {
                                        return area[0].id !== markAreaId;
                                    });

                                    otherMarkData = otherMarkData.filter(function (area) {
                                        return area[0].id !== markAreaId;
                                    });

                                    // 更新图表
                                    // selectedOption.series[0].markArea.data = markData;
                                    if (findDatastatus) {
                                        selectedOption.series[0].markArea.data = otherMarkData;
                                    } else {
                                        selectedOption.series[0].markArea.data = markData;
                                    }

                                    charts[0].setOption(selectedOption);

                                    // TODO 需要修改pyside6的按键状态
                                    delectState = false;
                                }
                            });
                        }
                    }
                    else {
                        // TODO 加入start和end时间
                        // Extract the clicked box's data
                        var clickedData = params.data;
                        if (clickedData.name === 'data') {

                            backend.get_label_option().then(selectOption => {
                                if (selectOption) {
                                    console.log('Received:', selectOption);

                                    if (!labelColors[selectOption]) {
                                        // 找到第一个未使用的颜色
                                        let nextColor = colorPalette.find(color => !usedColors.has(color));
                                        if (nextColor) {
                                            labelColors[selectOption] = nextColor;
                                            usedColors.add(nextColor); // 标记为已使用
                                        } else {
                                            console.error('No available colors left in the palette.');
                                            return;
                                        }
                                    }

                                    const itemStyle = {
                                        color: labelColors[selectOption]
                                    };

                                    // Update the color of the selected markArea using dataIndex
                                    const index = params.dataIndex;
                                    if (index !== undefined && selectedOption.series[0].markArea.data[index]) {
                                        selectedOption.series[0].markArea.data[index][0].itemStyle = itemStyle;
                                    }

                                    var currentZoom = charts[0].getOption().dataZoom[0];
                                    charts[0].setOption(selectedOption);
                                    charts[0].dispatchAction({
                                        type: 'dataZoom',
                                        start: currentZoom.start,
                                        end: currentZoom.end
                                    });

                                    // Reformat clickedData for markArea
                                    let markAreaData = [
                                        {
                                            name: selectOption,
                                            itemStyle: itemStyle,
                                            xAxis: clickedData.coord[0][0]  // 使用第一个坐标的 x 值
                                        },
                                        {
                                            xAxis: clickedData.coord[1][0]  // 使用第二个坐标的 x 值
                                        }
                                    ];

                                    // 检查是否与现有的数据重叠
                                    let hasOverlap = false;
                                    let overlappingIndexes = [];

                                    markData.forEach((existingArray, index) => {
                                        const existingStart = existingArray[0].xAxis;
                                        const existingEnd = existingArray[1].xAxis;
                                        const newStart = markAreaData[0].xAxis;
                                        const newEnd = markAreaData[1].xAxis;

                                        // 判断是否有重叠
                                        const isOverlapping = !(existingEnd <= newStart || existingStart >= newEnd);

                                        if (isOverlapping) {
                                            hasOverlap = true;
                                            overlappingIndexes.push(index);
                                        }
                                    });

                                    if (hasOverlap) {
                                        // 调用 PySide6 的 confirmOverlap 方法
                                        backend.confirmOverlap().then(userConfirmed => {
                                            if (userConfirmed) {
                                                // 去掉旧的重叠区域
                                                overlappingIndexes.reverse().forEach(index => {
                                                    markData.splice(index, 1);
                                                });
                                                // 添加新的数据
                                                markData.push(markAreaData);
                                            }
                                        });
                                    } else {
                                        // 如果没有重叠，直接添加新的数据
                                        markData.push(markAreaData);
                                    }

                                } else {
                                    console.error('No option received');
                                }
                            }).catch(error => {
                                console.error('Error fetching label option:', error);
                            });
                        }

                    }
                }
            });
        }

        function updatePointPosition() {
            // 取消高亮点
            charts.forEach(chart => {
                chart.setOption({
                    graphic: []
                });
            });
        }
        // 函数：将框选的x轴数据作为markArea添加到第一个图表
        function addLabel(selectedValue) {
            const currentTimestamp = Date.now();

            // if (!labelColors[selectedValue]) {
            //     // 生成随机颜色并存储
            //     labelColors[selectedValue] = '#' + Math.floor(Math.random() * 16777215).toString(16);
            // }

            if (!labelColors[selectedValue]) {
                // 找到第一个未使用的颜色
                let nextColor = colorPalette.find(color => !usedColors.has(color));
                if (nextColor) {
                    labelColors[selectedValue] = nextColor;
                    usedColors.add(nextColor); // 标记为已使用
                } else {
                    console.error('No available colors left in the palette.');
                    return;
                }
            }
            if (brushAreas.length > 0) {
                const newArea = {
                    name: selectedValue,
                    xAxis: new Date(brushAreas[0].timestamp).toISOString(),
                    // yAxis: '10',// 或者具体的值，比如 '10'
                    id: currentTimestamp,
                    timestamp: {
                        start: brushAreas[0].unixtime,
                        end: brushAreas[brushAreas.length - 1].unixtime
                    },
                    itemStyle: {
                        color: labelColors[selectedValue],  // 使用标签对应的颜色
                    },
                };
                const newAreaEnd = {
                    xAxis: new Date(brushAreas[brushAreas.length - 1].timestamp).toISOString(),
                    // yAxis: '90',// 或者具体的值，比如 '90'
                };
                const newArray = [newArea, newAreaEnd];
                // 检查是否与现有的数据重叠
                let hasOverlap = false;
                let overlappingIndexes = [];

                markData.forEach((existingArray, index) => {
                    const existingStart = existingArray[0].xAxis;
                    const existingEnd = existingArray[1].xAxis;
                    const newStart = newArea.xAxis;
                    const newEnd = newAreaEnd.xAxis;

                    // 判断是否有重叠
                    const isOverlapping = !(existingEnd <= newStart || existingStart >= newEnd);

                    if (isOverlapping) {
                        hasOverlap = true;
                        overlappingIndexes.push(index);
                    }
                });

                if (hasOverlap) {
                    // 调用 PySide6 的 confirmOverlap 方法
                    backend.confirmOverlap().then(userConfirmed => {
                        if (userConfirmed) {
                            // if (userConfirmed === true) {  // 明确检查是否为 true

                            // 去掉旧的重叠区域
                            overlappingIndexes.reverse().forEach(index => {
                                markData.splice(index, 1);
                            });
                            // 添加新的数据
                            markData.push(newArray);
                            // 同时将数据添加到otherMarkData
                            otherMarkData.unshift(newArray);
                            // otherMarkData.push(newArray);

                            if (findDatastatus) {
                                selectedOption.series[0].markArea.data = otherMarkData;
                            } else {
                                selectedOption.series[0].markArea.data = markData;
                            }
                            charts[0].setOption(selectedOption);
                        }
                    });
                } else {
                    // 如果没有重叠，直接添加新的数据
                    markData.push(newArray);
                    // 同时将数据添加到otherMarkData
                    otherMarkData.unshift(newArray);
                    // otherMarkData.push(newArray);
                }

                const currentZoom = charts[0].getOption().dataZoom;

                if (findDatastatus) {
                    selectedOption.series[0].markArea.data = otherMarkData;
                } else {
                    selectedOption.series[0].markArea.data = markData;
                }

                charts[0].setOption(selectedOption);
                if (currentZoom) {
                    charts[0].setOption({
                        dataZoom: currentZoom
                    });
                }

                // 清除框选
                charts.forEach((chart, i) => {
                    chart.dispatchAction({
                        type: 'brush',
                        areas: []
                    });
                });

            } else {
                console.error('No brush areas available to apply as markArea.');
            }
        }


        function displayData(data) {
            console.log("Received data type:", typeof data);
            // 先重置所有变量
            firstChartsData =
            {
                name: 'seclection',
                xAxisName: 'timestamp',
                yAxisName: 'Y Axis 1',
                series: ['timestamp']
            }
            chartsData = [];
            markData = [];
            otherMarkData = [];
            selectedDataList = null;
            oldFrame = null;
            delectState = false;
            lineOption = null;
            div_chart_name = {};

            // Replace NaN with null手动替换空值
            data = data.replace(/NaN/g, 'null');

            const parsedData = JSON.parse(data);

            // Extract metadata and data from the parsed JSON
            chartsData = parsedData.metadata;
            org_data = parsedData.data;
            labelColors = parsedData.labelColors;

            // console.log("Metadata:", metadata);
            // console.log("Filtered Data:", filteredData);

            initialize();

        }

        // 点击图表高亮地图对应的标记
        // handleHighlightDotByIndex
        function HighlightDotByIndex(index) {
            highlightLineChartDotByIndex(index)

            backend.handleHighlightDotByIndex(index);

            // 右边图中的对应时间的点也高亮显示
            backend.handleHighlightScatterDotByIndex(index);
        }


        // TODO 分开显示数据,手动打标签要可用，同时将手动打标签的数据插入到两个数据里，这样在find data状态下也能手动打标签，重叠标签的问题，这个重叠标签处理逻辑和原来手动打标签遇到重叠标签的处理逻辑一样
        function setMarkData(data) {
            // 设置标记，如果是在find data状态，标志为true
            findDatastatus = true;

            // 解析 JSON 数据
            const parsedData = JSON.parse(data);

            // 转换 xAxis 字段
            parsedData.forEach(mark => {
                if (mark.name === 'data' && mark.xAxis) {
                    mark.xAxis = new Date(mark.xAxis).toISOString();
                }
            });

            // 更新其他标记数据
            otherMarkData = parsedData;

            // 获取当前的 dataZoom 状态
            const currentOption = charts[0].getOption();
            const dataZoomState = currentOption.dataZoom ? currentOption.dataZoom : [];

            // console.log(otherMarkData);
            selectedOption.series[0].markArea.data = otherMarkData;
            // 保持原有的缩放状态
            selectedOption.dataZoom = dataZoomState;
            charts[0].setOption(selectedOption);

        }


        // 清除所有标记的时候将标记改为原来的标签内容
        function clearMarkData() {
            findDatastatus = false;
            otherMarkData = [];
            charts[0].setOption({
                series: [{
                    markArea: {
                        data: markData
                    }
                }]
            });
        }

        // 重置所有变量
        function handleComboxChange(data) {
            firstChartsData =
            {
                name: 'seclection',
                xAxisName: 'timestamp',
                yAxisName: 'Y Axis 1',
                series: ['timestamp']
            }
            chartsData = [];
            markData = [];
            otherMarkData = [];
            selectedDataList = null;
            oldFrame = null;
            delectState = false;
            lineOption = null;
            chartsData = JSON.parse(data)
            chart_list = chartsData.map(item => item.name);

            // // 如果div_chart_name中有chart_list中没有的chart，将对应div_chart_name中的key对应的div隐藏，有的不隐藏
            // for (const key in div_chart_name) {
            //     if (!chart_list.includes(div_chart_name[key])) {
            //         document.getElementById(key).style.display = 'none';
            //     }
            //     else {
            //         document.getElementById(key).style.display = 'block';
            //     }
            // }

            // // 如果chart_list中有div_chart_name中没有的chart，就初始化
            // for (const item of chartsData) {
            //     if (!Object.values(div_chart_name).includes(item.name)) {
            //         initialize();
            //     }
            // }
       

            clearBoxes().then(() => {
                initialize();
            });
            // clearBoxes()
            // initialize()
        }

        // 仅隐藏div
        function hideDiv() {
            var container = document.getElementById('container');
            container.style.display = 'none';
        }


        function handleLabelColorChange(data) {
            labelColors = JSON.parse(data);
        }

        // 使用回调函数或 Promise 来确保 clearBoxes 完成后再调用 initialize
        function clearBoxes() {
            return new Promise((resolve) => {
                const container = document.getElementById('container');
                while (container.firstChild) {
                    container.removeChild(container.firstChild);
                }
                resolve();
            });
        }

        // function clearBoxes() {
        //     const container = document.getElementById('container');
        //     while (container.firstChild) {
        //         container.removeChild(container.firstChild);
        //     }
        // }


        function deleteLabel(status) {
            delectState = status;
        }

        function getSelectedArea() {
            console.log(markData)
            // const currentMarkdata = selectedOption.series[0].markArea.data
            // return currentMarkdata;

            return JSON.stringify(markData);
        }

        function setStartTimeEndtime(startTime, endTime) {
            console.log(startTime, endTime)
            backend.setStartEndTimeToLabel(startTime, endTime);
        }

        function setStartAndEndData(startIndex, startLongitude, startLatitude, endIndex, endLongitude, endLatitude) {
            // console.log(startIndex,startLongitude,startLatitude,endIndex,endLongitude,endLatitude)

            backend.setStartAndEndData(startIndex, startLongitude, startLatitude, endIndex, endLongitude, endLatitude);
        }

        function highlightLineChartDotByIndex(index) {
            if (index !== -1) {
                var currentZoom = charts[0].getOption().dataZoom[0];
                var start = currentZoom.start;
                var end = currentZoom.end;

                var visibleRange = (end - start) / 100 * org_data.length;
                var visibleStartIndex = Math.floor(start / 100 * org_data.length);

                var centerOffset = Math.floor(visibleRange / 2);
                var newStartIndex = Math.max(0, index - centerOffset);
                var newStart = (newStartIndex / org_data.length) * 100;
                var newEnd = newStart + (end - start);

                var indexInt = parseInt(index, 10); // 转为整数

                charts.forEach((chart, i) => {
                    chart.dispatchAction({
                        type: 'dataZoom',
                        start: newStart,
                        end: newEnd
                    });
                    chart.dispatchAction({
                        type: 'downplay',
                        seriesIndex: [0, 1, 2]
                    });
                    chart.dispatchAction({
                        type: 'highlight',
                        seriesIndex: [0, 1, 2],
                        dataIndex: index
                    });

                    // 使用graphic来确保在降采样下也能高亮标点
                    var xPos = chart.convertToPixel({ xAxisIndex: 0 }, indexInt);
                    var yPos = chart.convertToPixel({ yAxisIndex: 0 }, 0); // Position on x-axis

                    chart.setOption({
                        graphic: [{
                            type: 'circle',
                            shape: { cx: 0, cy: 0, r: 5 },
                            style: { fill: 'red' },
                            position: [xPos, yPos],
                            z: 100
                        }]
                    });
                });
            }
        }


        function resizeCharts() {
            if (typeof charts !== 'undefined') {
                charts.forEach((chart, index) => {
                    var box = document.getElementById('chart-box-' + (index + 1));
                    var div = document.getElementById('chart' + (index + 1));

                    if (box && div) {
                        div.style.width = box.clientWidth + 'px';
                        div.style.height = box.clientHeight + 'px';
                        chart.resize();
                    }
                });
            }
            // var chartCount = document.querySelectorAll('.chart-box').length;
            // var totalHeight = (chartCount - 2)* 30;
            // // document.documentElement.style.height = totalHeight + '%';
            // document.body.style.height = totalHeight + '%';
        }


        function getSelectedData(data, areas) {
            var selectedData = [];

            areas.forEach(area => {
                var xRange = area.coordRange;

                var filteredData = data.filter((item, index) => {
                    return index >= xRange[0] && index <= xRange[1];
                });

                selectedData = selectedData.concat(filteredData);
            });

            return selectedData;
        }

        function updateTheme(theme) {

            if (theme === 'dark') {
                chartsTheme = 'dark';
                document.body.className = 'dark-mode';
                charts.forEach(chart => {
                    chart.setOption(darkTheme);
                });
            } else {
                chartsTheme = 'light';
                document.body.className = 'light-mode';
                charts.forEach(chart => {
                    chart.setOption(lightTheme);
                });
            }
        }

        
        // displayData(test_data);        
        window.addEventListener('resize', resizeCharts);


        // resizeCharts(); // 初始化时调用一次
        // brushEnd();
        new QWebChannel(qt.webChannelTransport, function (channel) {
            // console.log(channel)
            // console.log(channel.objects)
            // console.log(channel.objects.backend)
            window.backend = channel.objects.backend;
        });
        // document.documentElement.style.overflow = "hidden";
    </script>
</body>

</html>