<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>Multiple Line Charts with ECharts</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script>
    <script src="qrc:///qtwebchannel/qwebchannel.js"></script>
    <style>
        /* .chart-box {
            width: 600px;
            height: 400px;
            margin: 10px;
            border: 1px solid #ccc;
        } */
        html,
        body {
            height: 100%;
            margin: 0;
            background-color: #19232d;
        }

        body.dark-mode {
            background-color: #19232d;
            color: white;
        }

        body.light-mode {
            background-color: #FAFAFA;
            color: black;
        }

        #container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            flex-direction: column;
        }

        /* 不设置最小高度的话去掉border会导致最后一个图表丢失 */
        .chart-box {
            width: 100%;
            min-height: 50px;
            /* 设置最小高度 */
            /* margin: 2px 0;  */
            /* background-color: lightblue; */
            /* border: 1px solid #ccc; */
        }

        .chart-box:first-child {
            /* height: 150px; */
            height: 100px;
            min-height: 50px;
            /* 设置最小高度 */
            /* 固定高度 */
            flex: 0 0 auto;
            /* 固定大小，不参与均分 */
        }

        .chart-box:not(:first-child) {
            flex: 1;
            /* 均分剩余高度 */
        }

        .chart-container {
            width: 100%;
            height: 100%;
        }

        /* body {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
        } */
    </style>
</head>

<body>
    <div id="container"></div>

    <script type="text/javascript">
        let selectedOption = {};
        markData = [];
        otherMarkData = [];
        selectedDataList = null;
        chartsTheme = 'dark';
        oldFrame = null;
        delectState = false;
        lineOption = null;
        timestamps = null;
        dataFrame = null;
        let isBoxDrawn = false;
        let currentBox = null; // 用于存储当前绘制的框
        let filteredData = null;
        let labelColors = {};
        onbrush = false;
        // 全局变量存储框选的范围
        let brushAreas = [];
        let charts = [];

        // 定义dark主题
        var darkTheme = {
            backgroundColor: '#19232d'
        };

        var lightTheme = {
            backgroundColor: '#FAFAFA'
        };


        // let org_data = [
        //     { index: 0, timestamp: '2024-07-20T12:00:00Z', _timestamp: 1626787200, acc_x: 0.1, acc_y: 0.2, acc_z: 0.3, gyro_x: 13, gyro_y: 14, gyro_z: 15 },
        //     { index: 1, timestamp: '2024-07-20T12:01:00Z', _timestamp: 1626787260, acc_x: 0.2, acc_y: 0.3, acc_z: 0.4, gyro_x: 13, gyro_y: 14, gyro_z: 15 },
        //     { index: 2, timestamp: '2024-07-20T12:02:00Z', _timestamp: 1626787320, acc_x: 0.3, acc_y: 0.4, acc_z: 0.5, gyro_x: 13, gyro_y: 14, gyro_z: 15 },
        //     { index: 3, timestamp: '2024-07-20T12:03:00Z', _timestamp: 1626787380, acc_x: 0.4, acc_y: 0.5, acc_z: 0.6, gyro_x: 13, gyro_y: 14, gyro_z: 15 },
        //     { index: 4, timestamp: '2024-07-20T12:04:00Z', _timestamp: 1626787440, acc_x: 0.5, acc_y: 0.6, acc_z: 0.7, gyro_x: 13, gyro_y: 14, gyro_z: 15 },
        //     { index: 5, timestamp: '2024-07-20T12:05:00Z', _timestamp: 1626787500, acc_x: 0.6, acc_y: 0.7, acc_z: 0.8, gyro_x: 13, gyro_y: 14, gyro_z: 15 },
        //     { index: 6, timestamp: '2024-07-20T12:06:00Z', _timestamp: 1626787560, acc_x: 0.7, acc_y: 0.8, acc_z: 0.9, gyro_x: 13, gyro_y: 14, gyro_z: 15 },
        //     { index: 7, timestamp: '2024-07-20T12:07:00Z', _timestamp: 1626787620, acc_x: 0.8, acc_y: 0.9, acc_z: 1.0, gyro_x: 13, gyro_y: 14, gyro_z: 15 },
        //     { index: 8, timestamp: '2024-07-20T12:08:00Z', _timestamp: 1626787680, acc_x: 0.9, acc_y: 1.0, acc_z: 1.1, gyro_x: 13, gyro_y: 14, gyro_z: 15 },
        //     { index: 9, timestamp: '2024-07-20T12:09:00Z', _timestamp: 1626787740, acc_x: 1.0, acc_y: 1.1, acc_z: 1.2, gyro_x: 13, gyro_y: 14, gyro_z: 15 },
        //     { index: 10, timestamp: '2024-07-20T12:10:00Z', _timestamp: 1626787800, acc_x: 1.1, acc_y: 1.2, acc_z: 1.3, gyro_x: 13, gyro_y: 14, gyro_z: 15 },
        //     { index: 11, timestamp: '2024-07-20T12:11:00Z', _timestamp: 1626787860, acc_x: 1.2, acc_y: 1.3, acc_z: 1.4, gyro_x: 13, gyro_y: 14, gyro_z: 15 },
        //     { index: 12, timestamp: '2024-07-20T12:12:00Z', _timestamp: 1626787920, acc_x: 1.3, acc_y: 1.4, acc_z: 1.5, gyro_x: 13, gyro_y: 14, gyro_z: 15 },
        //     { index: 13, timestamp: '2024-07-20T12:13:00Z', _timestamp: 1626787980, acc_x: 1.4, acc_y: 1.5, acc_z: 1.6, gyro_x: 13, gyro_y: 14, gyro_z: 15 },
        //     { index: 14, timestamp: '2024-07-20T12:14:00Z', _timestamp: 1626788040, acc_x: 1.5, acc_y: 1.6, acc_z: 1.7, gyro_x: 13, gyro_y: 14, gyro_z: 15 },
        //     { index: 15, timestamp: '2024-07-20T12:15:00Z', _timestamp: 1626788100, acc_x: 1.6, acc_y: 1.7, acc_z: 1.8, gyro_x: 13, gyro_y: 14, gyro_z: 15 },
        //     { index: 16, timestamp: '2024-07-20T12:16:00Z', _timestamp: 1626788160, acc_x: 1.7, acc_y: 1.8, acc_z: 1.9, gyro_x: 13, gyro_y: 14, gyro_z: 15 },
        //     { index: 17, timestamp: '2024-07-20T12:17:00Z', _timestamp: 1626788220, acc_x: 1.8, acc_y: 1.9, acc_z: 2.0, gyro_x: 13, gyro_y: 14, gyro_z: 15 },
        //     { index: 18, timestamp: '2024-07-20T12:18:00Z', _timestamp: 1626788280, acc_x: 1.9, acc_y: 2.0, acc_z: 2.1, gyro_x: 13, gyro_y: 14, gyro_z: 15 },
        //     { index: 25, timestamp: '2024-07-20T12:19:00Z', _timestamp: 1626788340, acc_x: 2.0, acc_y: 2.1, acc_z: 2.2, gyro_x: 13, gyro_y: 14, gyro_z: 15 },
        //     { index: 26, timestamp: '2024-07-20T12:20:00Z', _timestamp: 1626788400, acc_x: 2.1, acc_y: 2.2, acc_z: 2.3, gyro_x: 13, gyro_y: 14, gyro_z: 15 },
        //     { index: 27, timestamp: '2024-07-20T12:21:00Z', _timestamp: 1626788460, acc_x: 2.2, acc_y: 2.3, acc_z: 2.4, gyro_x: 13, gyro_y: 14, gyro_z: 15 },
        //     { index: 28, timestamp: '2024-07-20T12:22:00Z', _timestamp: 1626788520, acc_x: 2.3, acc_y: 2.4, acc_z: 2.5, gyro_x: 13, gyro_y: 14, gyro_z: 15 },
        // ];

        let org_data = [];
        let chartsData = [
            {
                name: 'acceleration',
                xAxisName: 'timestamp',
                yAxisName: 'Y Axis 1',
                series: ['acc_x', 'acc_y', 'acc_z']
            },
            {
                name: 'gyroscope',
                xAxisName: 'timestamp',
                yAxisName: 'Y Axis 2',
                series: ['gyro_x', 'gyro_y', 'gyro_z']
            }
        ];

        // firstChartsData是占位图表，固定不变,里面的series是会被作为x轴
        var firstChartsData =
        {
            name: 'seclection',
            xAxisName: 'timestamp',
            yAxisName: 'Y Axis 1',
            series: ['timestamp']
        }

        // const chartsData = [
        //     {
        //         name: 'acceleration',
        //         xAxisName: 'timestamp',
        //         yAxisName: 'Y Axis 1',
        //         series: ['acc_x', 'acc_y', 'acc_z']
        //     },
        //     {
        //         name: 'gyroscope',
        //         xAxisName: 'timestamp',
        //         yAxisName: 'Y Axis 2',
        //         series: ['gyro_x', 'gyro_y', 'gyro_z']
        //     }
        // ];
        function convertData(org_data, firstChartsData, chartsData) {
            const result = {};

            // Initialize xAxis with values
            // result.firstChartsData.xAxisName = data.map(entry => entry[firstChartsData.xAxisName]);

            // // Initialize series arrays
            // firstChartsData.series.forEach(seriesName => {
            //     result[seriesName] = data.map(entry => entry[seriesName]);
            // });
            // Initialize series arrays
            firstChartsData.series.forEach(seriesName => {
                result[seriesName] = org_data.map(entry => {
                    const value = entry[seriesName];
                    return new Date(value).toISOString();
                });
            });

            chartsData.forEach(chart => {
                chart.series.forEach(seriesName => {
                    result[seriesName] = org_data.map(entry => entry[seriesName]);
                });
            });

            return result;
        }


        // const convertedData = convertData(data, firstChartsData, chartsData);
        // console.log(convertedData);

        function initialize() {
            dataFrame = convertData(org_data, firstChartsData, chartsData);



            // chartsData.unshift(firstChartsData);

            if (!chartsData.includes(firstChartsData)) {
                chartsData.unshift(firstChartsData);
            }

            // 获取容器元素
            var container = document.getElementById('container');

            // 清空容器中的内容
            container.innerHTML = '';


            // 动态创建多个盒子
            chartsData.forEach((chartData, index) => {
                if (chartData.series && chartData.series.length > 0) {
                    var box = document.createElement('div');
                    box.className = 'chart-box';
                    box.id = 'chart-box-' + (index + 1);
                    container.appendChild(box);
                }
            });

            // 将图表 div 添加到对应的 className 为 chart_box 的容器中
            chartsData.forEach((chartData, index) => {
                if (chartData.series && chartData.series.length > 0) {
                    var box = document.getElementById('chart-box-' + (index + 1));
                    var div = document.createElement('div');
                    div.className = 'chart-container';
                    div.id = 'chart' + (index + 1);
                    box.appendChild(div);

                    // 获取 box 的宽高
                    var width = box.clientWidth;
                    var height = box.clientHeight;

                    // 配置图表
                    var chart = echarts.init(div);
                    charts.push(chart);

                    if (chartsTheme === 'light') {
                        chart.setOption(lightTheme);
                    } else {
                        chart.setOption(darkTheme);
                    }

                    var series = [];
                    chartData.series.forEach(seriesName => {
                        if (dataFrame[seriesName]) {
                            series.push({
                                name: seriesName,
                                type: 'line',
                                data: dataFrame[seriesName],
                                sampling: 'lttb',
                                emphasis: {
                                    itemStyle: {
                                        color: 'red',
                                        borderColor: 'red',
                                        borderWidth: 4,

                                    },
                                    Symbol: 'circle',
                                    symbolSize: 20
                                }
                            });
                        }
                    });

                    var option = {
                        grid: {
                            top: 10,
                            bottom: 20
                        },
                        title: {
                            // text: 'Line Chart ' + (index + 1)
                            text: chartData.name
                        },
                        brush: {
                            brushType: ['lineX', 'clear'],
                            toolBox: ['lineX', 'clear'],
                            xAxisIndex: 'all',
                        },
                        toolbox: {
                            trigger: 'axis',
                            feature: {
                                brush: {
                                    type: ['lineX', 'clear']
                                }
                            }
                        },
                        legend: {
                            data: chartData.series,
                            orient: 'vertical',
                            right: '5%',
                            top: '5%'
                        },
                        xAxis: {
                            name: chartData.xAxisName,
                            type: 'category',
                            data: dataFrame[chartData.xAxisName],
                            animation: false,
                            animationThreshold: 5000,
                        },
                        yAxis: {
                            name: chartData.yAxisName,
                            type: 'value',
                            animation: false
                        },
                        series: series,
                        dataZoom: [
                            {
                                type: 'inside',
                                xAxisIndex: [0],
                                start: 0,
                                end: 100
                            }
                        ]
                    };

                    // 如果是第一个图表，添加特殊的配置
                    if (index === 0) {
                        // 可以在这里添加第一个图表的特殊配置
                        selectedOption = {
                            grid: {
                                top: 10,
                                bottom: 20
                            },
                            xAxis: {
                                type: 'category',
                                data: dataFrame[chartData.xAxisName] // 保持与原始图表一致的X轴数据
                            },
                            yAxis: {
                                type: 'value',
                                min: 1 // 设置y轴最小值为1
                            },
                            series: [{
                                type: 'line',
                                markArea: {
                                    data: [],
                                    label: {
                                        show: true, // 显示标签
                                        position: 'inside', // 标签位置为区域内部
                                        color: '#000', // 标签颜色
                                        fontSize: 14, // 标签字体大小
                                        formatter: function (params) {
                                            return params.name; // 使用区域的名称作为标签内容
                                        }
                                    }
                                },
                                data: [], // 空数据
                                showSymbol: false, // 不显示数据点
                                lineStyle: {
                                    opacity: 0 // 使线条透明
                                }
                            }],
                            dataZoom: [
                                {
                                    type: 'inside',
                                    xAxisIndex: [0],
                                    start: 0,
                                    end: 100
                                }
                            ]
                        };
                        chart.setOption(selectedOption);
                        return;
                    }

                    // 如果是最后一个图表，添加 dataZoom 配置
                    if (index === chartsData.length - 1) {
                        option.grid = {
                            top: 10
                        };
                        option.dataZoom = [
                            {
                                type: 'slider',
                                show: true,
                                xAxisIndex: [0],
                                start: 0,
                                end: 100
                            },
                            {
                                type: 'inside',
                                xAxisIndex: [0],
                                start: 0,
                                end: 100
                            }
                        ];
                    }
                    chart.setOption(option);

                    chart.on('click', function (params) {
                        var index = params.dataIndex;
                        console.log('click', index);
                        HighlightDotByIndex(index);
                    });


                    chart.getZr().on('click', function (event) {
                        // 没有 target 意味着鼠标/指针不在任何一个图形元素上，它是从“空白处”触发的。
                        if (!event.target) {
                            // 点击在了空白处，做些什么。
                            lineChart.dispatchAction({
                                type: 'downplay',
                                seriesIndex: [0, 1, 2],
                                // dataIndex: selectedIndex
                            });
                        }
                    });
                    // TUDO 同步缩放图表
                    // 监听缩放事件
                    // chart.on('dataZoom', function(params) {
                    //     charts.forEach(function(otherChart) {
                    //         if (otherChart !== chart) {
                    //         if (params.batch) {
                    //             otherChart.dispatchAction({
                    //                 type: 'dataZoom',
                    //                 start: params.batch[0].start,
                    //                 end: params.batch[0].end
                    //             });

                    //         } else {
                    //             otherChart.dispatchAction({
                    //                 type: 'dataZoom',
                    //                 start: params.start,
                    //                 end: params.end
                    //             });
                    //         }
                    //         }
                    //     });
                    // });
                }
            });
            brushEnd(charts);
        }

        function brushEnd(charts) {
            charts.forEach((chart, index) => {
                chart.on('brushEnd', function (params) {
                    console.log('BrushEnd Params:', params);

                    if (!params.areas) {
                        console.error('No areas data found in brushEnd params');
                        return;
                    }

                    var selectedData = getSelectedData(org_data, params.areas);
                    console.log('Selected Data:', selectedData);
                    setStartTimeEndtime(selectedData[0].timestamp, selectedData[selectedData.length - 1].timestamp);

                    // 取消其他图表的框选
                    charts.forEach((otherChart, otherIndex) => {
                        if (index !== otherIndex) {
                            otherChart.dispatchAction({
                                type: 'brush',
                                areas: []
                            });
                        }
                    });
                    // 存储框选的范围到全局变量
                    if (params.areas.length > 0) {
                        brushAreas = selectedData
                    }
                    // 测试使用
                    // addLabel('Selected Area');
                });

                document.addEventListener('contextmenu', function (event) {
                    event.preventDefault();
                    charts.forEach((otherChart, otherIndex) => {
                        if (index !== otherIndex) {
                            otherChart.dispatchAction({
                                type: 'brush',
                                areas: []
                            });
                        }
                    });
                    if (onbrush) {
                        chart.dispatchAction({
                            type: 'takeGlobalCursor',
                            key: 'brush',
                            brushOption: {
                                // brushType: 'clear',
                                brushType: false
                            },
                            areas: []
                        });
                        onbrush = false;
                    } else {
                        chart.dispatchAction({
                            type: 'takeGlobalCursor',
                            key: 'brush',
                            brushOption: {
                                brushType: 'lineX',
                                brushMode: 'single',
                            }
                        });
                        onbrush = true;
                    }
                });
            });

            charts[0].on('click', function (params) {
                // console.log('click', params);
                if (delectState) {
                    if (params.componentType === 'markArea') {
                        var markAreaId = params.data.id;
                        if (markAreaId) {

                            backend.confirmDelete().then(userConfirmed => {
                                if (userConfirmed) {
                                    // 同步删除 markData 中的对应数据
                                    markData = markData.filter(function (area) {
                                        return area[0].id !== markAreaId;
                                    });

                                    // 更新图表
                                    selectedOption.series[0].markArea.data = markData;
                                    charts[0].setOption(selectedOption);
                                    delectState = false;
                                    // document.getElementById('delectLabelButton').style.backgroundColor = '#1ea123';
                                }
                            });
                        }
                    }
                }
            });
        }

        // 函数：将框选的x轴数据作为markArea添加到第一个图表
        function addLabel(selectedValue) {
            const currentTimestamp = Date.now();
            // selectedValue = 'Selected Area';
            if (!labelColors[selectedValue]) {
                // 生成随机颜色并存储
                labelColors[selectedValue] = '#' + Math.floor(Math.random() * 16777215).toString(16);
            }
            if (brushAreas.length > 0) {
                const newArea = {
                    name: selectedValue,
                    xAxis: new Date(brushAreas[0].timestamp).toISOString(),
                    // yAxis: '10',// 或者具体的值，比如 '10'
                    id: currentTimestamp,
                    timestamp: {
                        start: brushAreas[0]._timestamp,
                        end: brushAreas[brushAreas.length - 1]._timestamp
                    },
                    itemStyle: {
                        color: labelColors[selectedValue],  // 使用标签对应的颜色
                    },
                };
                const newAreaEnd = {
                    xAxis: new Date(brushAreas[brushAreas.length - 1].timestamp).toISOString(),
                    // yAxis: '90',// 或者具体的值，比如 '90'
                };
                const newArray = [newArea, newAreaEnd];
                // 检查是否与现有的数据重叠
                let hasOverlap = false;
                let overlappingIndexes = [];

                markData.forEach((existingArray, index) => {
                    const existingStart = existingArray[0].xAxis;
                    const existingEnd = existingArray[1].xAxis;
                    const newStart = newArea.xAxis;
                    const newEnd = newAreaEnd.xAxis;

                    // 判断是否有重叠
                    const isOverlapping = !(existingEnd <= newStart || existingStart >= newEnd);

                    if (isOverlapping) {
                        hasOverlap = true;
                        overlappingIndexes.push(index);
                    }
                });

                if (hasOverlap) {
                    // 调用 PySide6 的 confirmOverlap 方法
                    backend.confirmOverlap().then(userConfirmed => {
                        if (userConfirmed) {
                            // if (userConfirmed === true) {  // 明确检查是否为 true

                            // 去掉旧的重叠区域
                            overlappingIndexes.reverse().forEach(index => {
                                markData.splice(index, 1);
                            });
                            // 添加新的数据
                            markData.push(newArray);

                            selectedOption.series[0].markArea.data = markData;
                            charts[0].setOption(selectedOption);
                        }
                    });
                } else {
                    // 如果没有重叠，直接添加新的数据
                    markData.push(newArray);
                }

                selectedOption.series[0].markArea.data = markData;
                charts[0].setOption(selectedOption);

                charts.forEach((chart, i) => {
                    chart.dispatchAction({
                        type: 'brush',
                        areas: [{
                            brushType: 'clear',
                            coordRange: []
                        }
                        ]
                    });
                });

                // charts.forEach((chart, i) => {
                //     chart.dispatchAction({
                //         type: 'brush',
                //         areas: [{
                //             brushType: 'clear',
                //             coordRange: []
                //         }
                //         ]
                //     });
                // });

            } else {
                console.error('No brush areas available to apply as markArea.');
            }
        }


        function displayData(data) {
            console.log("Received data type:", typeof data);
            // Replace NaN with null手动替换空值
            data = data.replace(/NaN/g, 'null');

            const parsedData = JSON.parse(data);

            // Extract metadata and data from the parsed JSON
            chartsData = parsedData.metadata;
            org_data = parsedData.data;

            // console.log("Metadata:", metadata);
            // console.log("Filtered Data:", filteredData);

            initialize();
        }

        // TUDO 点击图表高亮地图对应的标记
        // handleHighlightDotByIndex
        function HighlightDotByIndex(index) {
            backend.handleHighlightDotByIndex(index);
        }

        // function setMarkData(otherMarkData) {
        //     otherMarkData = JSON.parse(otherMarkData);
        //     console.log(otherMarkData)
        //     charts[0].setOption({
        //         series: [{
        //             markArea: {
        //                 data: otherMarkData
        //             }
        //         }]
        //     });
        // }
        function setMarkData(otherMarkData) {
            otherMarkData = JSON.parse(otherMarkData);

            // 遍历 otherMarkData 并转换 xAxis 字段
            otherMarkData.forEach(mark => {
                if (mark.hasOwnProperty('xAxis')) {
                    mark.xAxis = new Date(mark.xAxis).toISOString();
                }

                if (mark.name === 'data' && mark.hasOwnProperty('xAxis')) {
                    mark.xAxis = new Date(mark.xAxis).toISOString();
                }
            });

            console.log(otherMarkData);

            charts[0].setOption({
                series: [{
                    markArea: {
                        data: otherMarkData
                    }
                }]
            });
        }

        function clearMarkData() {
            otherMarkData = [];
            charts[0].setOption({
                series: [{
                    markArea: {
                        data: otherMarkData
                    }
                }]
            });
        }

        // TODO: 重置所有变量
        function handleComboxChange(data) {
            firstChartsData =
            {
                name: 'seclection',
                xAxisName: 'timestamp',
                yAxisName: 'Y Axis 1',
                series: ['timestamp']
            }
            chartsData = [];
            charts = [];
            markData = [];
            otherMarkData = [];
            selectedDataList = null;
            oldFrame = null;
            delectState = false;
            lineOption = null;
            chartsData = JSON.parse(data)
            clearBoxes().then(() => {
                initialize();
            });
            // clearBoxes()
            // initialize()
        }

        // 使用回调函数或 Promise 来确保 clearBoxes 完成后再调用 initialize
        function clearBoxes() {
            return new Promise((resolve) => {
                const container = document.getElementById('container');
                while (container.firstChild) {
                    container.removeChild(container.firstChild);
                }
                resolve();
            });
        }

        // function clearBoxes() {
        //     const container = document.getElementById('container');
        //     while (container.firstChild) {
        //         container.removeChild(container.firstChild);
        //     }
        // }


        function deleteLabel(status) {
            delectState = status;
        }

        function getSelectedArea() {
            console.log(markData)
            // const currentMarkdata = selectedOption.series[0].markArea.data
            // return currentMarkdata;

            return JSON.stringify(markData);
        }

        function setStartTimeEndtime(startTime, endTime) {
            console.log(startTime, endTime)
            backend.setStartEndTimeToLabel(startTime, endTime);
        }

        function highlightLineChartDotByIndex(index) {
            if (index !== -1) {
                // 按数据
                // var start = Math.max(0, (index - 10) / org_data.length * 100);
                // var end = Math.min(100, (index + 10) / org_data.length * 100);
                
                // 按固定显示的点数
                var totalPoints = 1000; 
                var halfPoints = totalPoints / 2;

                var start = Math.max(0, ((index - halfPoints) / org_data.length) * 100);
                var end = Math.min(100, ((index + halfPoints) / org_data.length) * 100);


                charts.forEach((chart, i) => {
                    chart.dispatchAction({
                        type: 'dataZoom',
                        start: start,
                        end: end
                    });
                    chart.dispatchAction({
                        type: 'downplay',
                        seriesIndex: [0, 1, 2],
                        // dataIndex: selectedIndex
                    });
                    chart.dispatchAction({
                        type: 'highlight',
                        seriesIndex: [0, 1, 2],
                        dataIndex: index
                    });
                });
            }
        }


        function resizeCharts() {
            if (typeof charts !== 'undefined') {
                charts.forEach((chart, index) => {
                    var box = document.getElementById('chart-box-' + (index + 1));
                    var div = document.getElementById('chart' + (index + 1));

                    if (box && div) {
                        div.style.width = box.clientWidth + 'px';
                        div.style.height = box.clientHeight + 'px';
                        chart.resize();
                    }
                });
            }
        }


        function getSelectedData(data, areas) {
            var selectedData = [];

            areas.forEach(area => {
                var xRange = area.coordRange;

                var filteredData = data.filter((item, index) => {
                    return index >= xRange[0] && index <= xRange[1];
                });

                selectedData = selectedData.concat(filteredData);
            });

            return selectedData;
        }

        function updateTheme(theme) {

            if (theme === 'dark') {
                chartsTheme = 'dark';
                document.body.className = 'dark-mode';
                charts.forEach(chart => {
                    chart.setOption(darkTheme);
                });
            } else {
                chartsTheme = 'light';
                document.body.className = 'light-mode';
                charts.forEach(chart => {
                    chart.setOption(lightTheme);
                });
            }
        }



        window.addEventListener('resize', resizeCharts);

        // function displayData(data) {
        //     console.log("Received data type:", typeof data);
        //     filteredData = JSON.parse(data);
        //     initialize()
        // }





        // resizeCharts(); // 初始化时调用一次
        // brushEnd();
        new QWebChannel(qt.webChannelTransport, function (channel) {
            // console.log(channel)
            // console.log(channel.objects)
            // console.log(channel.objects.backend)
            window.backend = channel.objects.backend;
        });
        document.documentElement.style.overflow = "hidden";
    </script>
</body>

</html>